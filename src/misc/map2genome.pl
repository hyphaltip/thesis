#!/usr/bin/perl -w

=head1 NAME

map2genome - map protein alignments to the genome

=head1 DESCRIPTION

This script maps protein HMMPFAM or BLASTP/FASTP hits to the genome.
You need to provide 3 things.  The input file, either in STDIN or on
the cmdline.

HMMER input should be in tab delimited format as generated by 
hmmer_to_table.PLS in bioperl under scripts/searchio/hmmer_to_table.PLS
The columns are 
  query sequence/domain (these are flip-flopped for hmmsearch / hmmpfam)  
  query start
  query end
  domain/sequence name or PFAM accession 
  hit start
  hit end
  score
  e-value
  domain/sequence name (these are flip-flopped for hmmsearch / hmmpfam)  

For BLASTP/FASTP results the data is in the standard NCBI -m9 columnar
format, this also available from the blast2table.pl script.  The
columns are
  query name
  subject name
  percent identity
  length alignment
  # mismatches
  # total gaps
  query start 
  query stop
  hit start
  hit stop
  E-value
  bits


-d protein database in fasta format where the description has the
 protein's genomic location encoded
   >ID LOCUS:LOCATION_STRING
A real example
   >ccin_GLEAN:GLEAN_gz2_00090 ccin_1.1:join(505..673,730..1286,1363..3447) cdslen=2811

See gff2cds.pl script for an example of how this can be generated.

-desc the database of description which match either ACCESSION nums to descriptions or pfamIDs to descriptions

The PFAM db can be generated with pfam2desc.pl
The db looks like
   >PFAMID|ACC DESCRIPTION
A real example
   >4_1_CTD|PF05902.2 4.1 protein C-terminal domain (CTD)

-t The type of data, hmmer or BLASTP


=head1 AUTHOR

Jason Stajich jason.stajich -at- duke.edu

=cut

use strict;
use Getopt::Long;
use Bio::DB::Fasta;
use Bio::Factory::FTLocationFactory;
use Bio::Location::Simple;
use Bio::Coordinate::GeneMapper;
use constant CODONLEN => 3;
use DB_File;


my $style = 'BLASTP';
my $db;
my $descdb;
my $force = 0;
my $minevalue;
GetOptions(
	   't|type|s|style:s'                => \$style,
	   'd|db:s'                   => \$db,
	   'desc|dbdesc|descdb:s'     => \$descdb,
	   'f|force'                  => \$force,
           'filter|me:s'              => \$minevalue,
	   );
die("need description db \n") unless $descdb;
die("need protein db with sequence locations\n") unless $db;

$style = uc $style;

my $dbh = Bio::DB::Fasta->new($db);
my $exists = (-e "$descdb.idx" && ! -z "$descdb.idx");

my %deschash;
my $descdbh = tie(%deschash,'DB_File', "$descdb.idx");
if( ! $exists || $force) {
    my $fh;
    open($fh => $descdb) || die $!;
    while(<$fh>) {	
	if( /^>(\S+)\s+(.+)/ ) {
	    my ($id,$rest) = ($1,$2);
	    s/^>//;
	    s/\001.+$//; # drop second	
	    my $line = $_;	    
	    if( $style eq 'HMMER' ) {
		if( $id =~ /^([\w\d\.\-]+)\|(PF\S+\.\d+)$/ ) {
		    $descdbh->put($1,$line);
		} else {
		    warn("no storing record $id\n");
		}
	    } else {
		$deschash{$id} = $line;
	    }
	}
    }
}

print "##gff-version 3\n";
while(<>) {
    my ($q,$h,$qs,$qe,$hs,$he,$evalue);
    if( $style eq 'BLASTP' ) {
	($q,$h,undef,undef,undef,undef,$qs,$qe,$hs,$he,$evalue) = split;
    } elsif( $style eq 'HMMER' ) {
	($q,$qs,$qe,$h,$hs,$he,undef,$evalue) = split;
    } else {
	warn "unknown style\n";
    }   
    next if defined $minevalue  && $evalue > $minevalue;
    my $hdr = $dbh->header($q);
    if( ! $hdr ) {
	warn("No protein named $q exists in db $db\n");
	next;
    }
    my ($id,$chrom,$locstr) = ( $hdr =~ /(\S+)\s+(\S+):(\S+)/);
    my $loc = Bio::Factory::FTLocationFactory->from_string($locstr);
    my ($chrom_start,$chrom_end,$chrom_strand);
    my @locs = grep { $_->start != $_->end } 
                  (sort { $a->strand * $a->start <=>
			      $b->strand * $b->start } 
		   $loc->each_Location);
    if( $locs[0]->strand > 0 ) {
#	my $runninglen = 0;
	$chrom_strand = '+';
#	for my $exon ( @locs ) {
	    # within
#	    warn($exon->to_FTstring, "\n");
#	    if( ($runninglen / CODONLEN) <= $qs &&
#		(($runninglen + $exon->length) / CODONLEN) >= $qs ) {
#		$chrom_start = (CODONLEN * ($qs-1)) + $exon->start;
#	    }
#	    if( ($runninglen / CODONLEN) <= $qe &&
#		(($runninglen + $exon->length) / CODONLEN) >= $qe ) {
#		$chrom_end = (CODONLEN * ($qe-1)) - $runninglen + $exon->start;
#	    }
#	    $runninglen += $exon->length;
#	}
#	unless( $chrom_end && $chrom_start ) {
#	    warn("could not find both start and end for $qs $qe $q $locstr $runninglen --- $chrom_start,$chrom_end\n");
#	    next;
#	}
    } else {
#	my $runninglen = 0;
	$chrom_strand = '-';
				  
#	warn($runninglen / 3, "\n");
#	unless( $chrom_end && $chrom_start ) {
#	    warn("could not find both start and end for $qs $qe $q $locstr\n");
#	    next;
#	}
    }
    my $mapper = Bio::Coordinate::GeneMapper->new(-in => 'peptide',
						  -out=> 'chr',
						  -exons=> \@locs);    
    my $newloc = $mapper->map(Bio::Location::Simple->new(-start => $qs,
							 -end   => $qe));
    if( ! $newloc ) {
	warn("cannot map $qs-$qe from @locs\n");
    }
    ($chrom_start,$chrom_end) = ($newloc->start,$newloc->end);
    next if( ! defined $chrom_start || ! defined $chrom_end );
	
    my $hdesc = $deschash{$h};
    unless( $hdesc ) {
	warn( " no $h description\n" );
	next;
    }
    my ($gi,$acc,$locus,$desc,$name);
    chomp($hdesc);
    if( $hdesc =~ /gi\|(\d+)\|\w+\|(\S+)\|(\S+)?\s+(.+)/ ) {
	($gi,$acc,$locus,$desc) = ($1,$2,$3,$4);
	$name = $locus || $acc;
    } elsif( $hdesc =~ /(\S+)\|(\S+)\s+(.+)/ ) {	
	($locus,$acc,$desc) = ($1,$2,$3);
	$name = $locus;
    }
    my $t = $style eq 'BLASTP' ? 'Protein' : 'Domain';
# GFF3
    $desc =~ tr/ /+/;
    $desc =~ s/([\t\n\=;,])/sprintf("%%%X",ord($1))/ge;
    my @lst = ("Target=$t:$name",
	       "Note=$desc",
	       "accession=$acc");
    push @lst, "gi=$gi" if $gi;
    
    print join("\t", 
	       $chrom,
	       $style eq 'HMMER' ? 'hmmer' : $style, # lc hmmer 'cause that's
                                                     # the way I like it
                                                     # (uh huh, uh huh)
	       'match',
	       $chrom_start,
	       $chrom_end,
	       $evalue,
	       $chrom_strand,
	       '.',
	       join(";", @lst)),"\n";
}
